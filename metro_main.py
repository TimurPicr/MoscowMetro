# -*- coding: utf-8 -*-
"""Metro_main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZBGr9Ohe6tVB5EyDresBo3wTNzNy7kL_
"""

import pandas as pd

file_path = "/content/пп_станции.xlsx"
data = pd.read_excel(file_path)

data

cleaned_data = data.drop(columns=['Дата'])
long_format_data = cleaned_data.melt(id_vars=['Станция', 'Номер линии'], var_name='Дата', value_name='Количество пассажиров')


long_format_data.head()

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose



def your_station(station_name):
  file_path = "/content/пп_станции.xlsx"
  data = pd.read_excel(file_path)
  cleaned_data = data.drop(columns=['Дата'])
  long_format_data = cleaned_data.melt(id_vars=['Станция', 'Номер линии'], var_name='Дата', value_name='Количество пассажиров')
  long_format_data.head()
  sorted_data = long_format_data.sort_values(by=['Станция', 'Дата'])
  grouped_data = sorted_data[sorted_data["Станция"] == station_name]
  if not isinstance(grouped_data.index, pd.DatetimeIndex):
      print(grouped_data['Дата'] )
      grouped_data['Дата'] = pd.to_datetime(grouped_data['Дата'])
      grouped_data.set_index('Дата', inplace=True)
  group = grouped_data.asfreq('D')
    # Выполняем декомпозицию временного ряда
  results = seasonal_decompose(group['Количество пассажиров'].dropna(), model='additive')
  results.plot()

  group = group.drop(columns=['Станция', 'Номер линии'])
  print(group)




your_station("Охотный ряд")

!pip install sktime
!pip install pmdarima

from sktime.forecasting.model_selection import temporal_train_test_split
from sktime.forecasting.base import ForecastingHorizon
from sktime.utils.plotting import plot_series


group['Количество пассажиров'] = group['Количество пассажиров'].astype(float)


y_train, y_test = temporal_train_test_split(group['Количество пассажиров'], test_size=19)

plot_series(y_train, y_test, labels=["y_train", "y_test"])

import pmdarima as pm
from pmdarima import model_selection
import pmdarima as pm

arima_model = pm.auto_arima(
    y_train,
    start_p=0, start_q=0,
    max_p=5, max_q=5,
    seasonal=True,
    m=7,
    d=None,
    D=1,
    trace=True,
    error_action='ignore',
    suppress_warnings=True,
    stepwise=True
)

print(arima_model.summary())

print(arima_model.summary())

import numpy as np


def predict_to_data(number):

  y_pred, pred_ci = arima_model.predict(
      n_periods=19 + number,
      return_conf_int=True,
      alpha=0.05
  )
  return y_pred[:len(y_test)], pred_ci[:len(y_test)]



predict_to_data(0)


def mape(predicted, true):
    return sqrt(mean_squared_error(predicted, true))

mape(y_pred[:len(y_test)], y_test)

import pandas as pd
from sklearn.metrics import mean_squared_error
from math import sqrt

print()
df_forecast = pd.DataFrame({
    'y_pred': y_pred,
    'ci_lower': pred_ci[:, 0],
    'ci_upper': pred_ci[:, 1]
})



print(df_forecast.index)

fig, ax = plot_series(y_train, y_test, df_forecast.y_pred, labels=["y_train", "y_test", "y_pred"]);
ax.fill_between(
    ax.get_lines()[-1].get_xdata(),
    df_forecast["ci_lower"],
    df_forecast["ci_upper"],
    alpha=0.05,
    color=ax.get_lines()[-1].get_c(),
    label=f"prediction intervals",
)
ax.legend(loc='lower left');

arima_model.plot_diagnostics(figsize=(10, 8));

def near(st, df): # Находим "переходные станции"
    df_near = df.loc[(df['Станция'].str.contains(st.split(' ')[0])) & (df['Станция'] != st)]
    return df_near

df = pd.read_excel('/content/пп_станции.xlsx') # Импорт данных

def get_features(st, line, df): # Дай таблицу
    self_time = df.loc[df['Станция'] == st].drop(['Станция', 'Номер линии', 'Дата'], axis=1).T # Поток станции

    near_st = near(st, df) # Поток ближайших станций
    if not near_st.empty:
        near_time = near_st.drop(['Станция', 'Номер линии', 'Дата'], axis=1)
        self_time = pd.concat([self_time,near_time.T], axis=1)


    return self_time

get_features('Белорусская', 8, df)
features = get_features('Белорусская', 8, df)



# Теперь сделаем с учётом соседей как фичи

# import pandas as pd
# file_path = "/content/пп_станции.xlsx"
# data = pd.read_excel(file_path)
# cleaned_data = data.drop(columns=['Дата'])
# long_format_data = cleaned_data.melt(id_vars=['Станция', 'Номер линии'], var_name='Дата', value_name='Количество пассажиров')
# sorted_data = long_format_data.sort_values(by=['Станция', 'Дата'])

# def near(st, df):
#     df_near = df.loc[(df['Станция'].str.contains(st.split(' ')[0])) & (df['Станция'] != st)]
#     df_near = df_near.drop(columns = ["Номер линии"])
#     print(df_near)


# station_name = "Белорусская"
# grouped_data = sorted_data[sorted_data["Станция"] == station_name]


# near(station_name, sorted_data)

import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt


p, d, q = 1, 1, 1


for column in features.columns:

    model = ARIMA(features[column], order=(p, d, q))
    results = model.fit()
    # print(f"Results for {column}:")
    # print(results.summary())

    forecast = results.forecast(steps=94)

    plt.plot(features.index, features[column], label='Original')
    plt.plot(features.index, forecast, label='Forecast', color='red')
    print(features.index)

    plt.figure()
    plt.legend()
    plt.show()

from sktime.forecasting.model_selection import temporal_train_test_split
from sktime.forecasting.base import ForecastingHorizon

y_train, y_test = temporal_train_test_split(y, test_size=48)
fh = ForecastingHorizon(y_test.index, is_relative=False)

plot_series(y_train, y_test, labels=["y_train", "y_test"])
print(y_train.shape[0], y_test.shape[0])